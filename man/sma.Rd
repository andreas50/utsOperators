% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/sma.R
\name{sma}
\alias{sma}
\alias{sma.uts}
\title{Simple Moving Average (SMA)}
\usage{
sma(x, ...)

\method{sma}{uts}(x, tau, type = "last", NA_method = "ignore", ...)
}
\arguments{
\item{x}{a time series object.}

\item{tau}{a \code{\link[lubridate]{duration}} object, specifying the temporal width of the rolling time window. Use positive values for backward-looking (i.e. normal, causal) SMAs, and negative values for forward-looking SMAs.}

\item{type}{the type of the SMA. Either \code{"equal"}, \code{"last"}, \code{"next"}, or \code{"linear"}. See below for details.}

\item{NA_method}{the method for dealing with \code{NA}s. Either \code{"fail"}, \code{"ignore"}, \code{"omit"}.}

\item{\dots}{further arguments passed to or from methods.}
}
\description{
Calculate a simple moving average (SMA) of a time series.
}
\details{
Four different SMAs types are supported for \code{"uts"} objects. Each type puts different weights on the observation values inside the rolling time window of width \code{tau}: \itemize{
\item \code{equal}: Each observation value is weighted equally.
\item \code{last}: Apply the moving average kernel to the time series sample path with \emph{last}-point interpolation. Equivalently, each observation value is weighted by how long it remained unchanged.
\item \code{next}: Apply the moving average kernel to the time series sample path with \emph{next}-point interpolation. Equivalently, each observation value is weighted by how long it remained the next (i.e. upcomming) observation.
\item \code{linear}: Apply the moving average kernel to the time series sample path with \emph{linear} interpolation. The behavior is approximately halfway in-between last-point and next-point interpolation.
}
See the reference below for precise mathematical definitions and on why one would use one SMA type over another.
}
\section{Methods (by class)}{
\itemize{
\item \code{uts}: simple moving average for \code{"uts"} objects.
}}
\examples{
sma(ex_uts(), ddays(1))
sma(ex_uts(), ddays(1), type="equal")
sma(ex_uts(), ddays(1), type="linear")
sma(ex_uts(), ddays(1), type="next")

# For SMA_equal, the original time series is returned,
# if the time window is narrow enough (modulo numerical noise)
sma(ex_uts(), dseconds(1), type="equal") - ex_uts()

# Plot a monotonically increasing time series 'x' together with
# a backward-looking and forward-looking SMA.
# Note how the forward-looking SMA is leading the increase in 'x', which
# in turn is leading the increase in the backward-looking SMA.
\dontrun{
  x <- uts(0:10, Sys.time() + dhours(0:10))
  par(mfrow=c(1, 3))
  plot(x, ylim=c(0, 10), main="Original time series")
  plot(sma(x, dhours(3)), ylim=c(0, 10), main="Backward-looking SMA")
  plot(sma(x, dhours(-3)), ylim=c(0, 10), main="Forward-looking SMA")
}

# Plot three different SMAs of a monotonically increasing time series
# Note that SMA_last(x)_t <= SMA_linear(x)_t <= SMA_next(x)_t for all observation times t
\dontrun{
  x <- uts(0:8, Sys.time() + dhours(0:8))
  par(mfrow=c(1, 3))
  plot(sma(x, dhours(10), type="last"), ylim=c(0, 4), main="Last-point interpolation")
  plot(sma(x, dhours(10), type="linear"), ylim=c(0, 4), main="Linear interpolation")
  plot(sma(x, dhours(10), type="next"), ylim=c(0, 4), main="Next-point interpolation")
}
}
\references{
Eckner, A. (2010) \emph{Algorithms for Unevenly Spaced Time Series: Moving Averages and Other Rolling Operators}.

Eckner, A. (2010) \emph{Algorithms for Unevenly Spaced Time Series: Moving Averages and Other Rolling Operators}.
}
\seealso{
\code{\link{ema}} for exponential moving averages.
}

